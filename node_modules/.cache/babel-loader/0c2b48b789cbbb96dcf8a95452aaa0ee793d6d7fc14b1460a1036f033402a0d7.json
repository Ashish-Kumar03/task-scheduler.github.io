{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Ashish\\\\CascadeProjects\\\\task-scheduler-app\\\\src\\\\contexts\\\\TaskContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst TaskContext = /*#__PURE__*/createContext();\nexport const useTask = () => {\n  _s();\n  const context = useContext(TaskContext);\n  if (!context) {\n    throw new Error('useTask must be used within a TaskProvider');\n  }\n  return context;\n};\n_s(useTask, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const TaskProvider = ({\n  children\n}) => {\n  _s2();\n  const [tasks, setTasks] = useState([]);\n  const [activeTimers, setActiveTimers] = useState({});\n  useEffect(() => {\n    // Load tasks from localStorage\n    const storedTasks = localStorage.getItem('taskflow_tasks');\n    if (storedTasks) {\n      setTasks(JSON.parse(storedTasks));\n    }\n  }, []);\n  useEffect(() => {\n    // Save tasks to localStorage whenever tasks change\n    localStorage.setItem('taskflow_tasks', JSON.stringify(tasks));\n  }, [tasks]);\n  const addTask = taskData => {\n    const newTask = {\n      id: uuidv4(),\n      ...taskData,\n      status: 'pending',\n      timeSpent: 0,\n      createdAt: new Date().toISOString(),\n      startedAt: null,\n      completedAt: null\n    };\n    setTasks(prev => [...prev, newTask]);\n    return newTask;\n  };\n  const updateTask = (taskId, updates) => {\n    setTasks(prev => prev.map(task => task.id === taskId ? {\n      ...task,\n      ...updates\n    } : task));\n  };\n  const deleteTask = taskId => {\n    setTasks(prev => prev.filter(task => task.id !== taskId));\n    // Stop timer if running\n    if (activeTimers[taskId]) {\n      stopTimer(taskId);\n    }\n  };\n  const startTimer = taskId => {\n    const task = tasks.find(t => t.id === taskId);\n    if (!task) return;\n\n    // Update task status and start time\n    updateTask(taskId, {\n      status: 'in-progress',\n      startedAt: task.startedAt || new Date().toISOString()\n    });\n\n    // Start interval timer\n    const startTime = Date.now();\n    const interval = setInterval(() => {\n      const elapsed = Math.floor((Date.now() - startTime) / 1000);\n      setTasks(prev => prev.map(task => task.id === taskId ? {\n        ...task,\n        timeSpent: (task.timeSpent || 0) + elapsed\n      } : task));\n    }, 1000);\n    setActiveTimers(prev => ({\n      ...prev,\n      [taskId]: {\n        interval,\n        startTime\n      }\n    }));\n  };\n  const stopTimer = taskId => {\n    const timer = activeTimers[taskId];\n    if (timer) {\n      var _tasks$find;\n      clearInterval(timer.interval);\n      const elapsed = Math.floor((Date.now() - timer.startTime) / 1000);\n      updateTask(taskId, {\n        timeSpent: (((_tasks$find = tasks.find(t => t.id === taskId)) === null || _tasks$find === void 0 ? void 0 : _tasks$find.timeSpent) || 0) + elapsed,\n        status: 'paused'\n      });\n      setActiveTimers(prev => {\n        const newTimers = {\n          ...prev\n        };\n        delete newTimers[taskId];\n        return newTimers;\n      });\n    }\n  };\n  const completeTask = taskId => {\n    // Stop timer if running\n    if (activeTimers[taskId]) {\n      stopTimer(taskId);\n    }\n    updateTask(taskId, {\n      status: 'completed',\n      completedAt: new Date().toISOString()\n    });\n  };\n  const getTasksByUser = userId => {\n    return tasks.filter(task => task.assignedTo === userId);\n  };\n  const getTaskStats = userId => {\n    const userTasks = getTasksByUser(userId);\n    return {\n      total: userTasks.length,\n      pending: userTasks.filter(t => t.status === 'pending').length,\n      inProgress: userTasks.filter(t => t.status === 'in-progress').length,\n      completed: userTasks.filter(t => t.status === 'completed').length,\n      overdue: userTasks.filter(t => t.status !== 'completed' && new Date(t.deadline) < new Date()).length\n    };\n  };\n  const value = {\n    tasks,\n    activeTimers,\n    addTask,\n    updateTask,\n    deleteTask,\n    startTimer,\n    stopTimer,\n    completeTask,\n    getTasksByUser,\n    getTaskStats\n  };\n  return /*#__PURE__*/_jsxDEV(TaskContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 149,\n    columnNumber: 5\n  }, this);\n};\n_s2(TaskProvider, \"2WvBOV9t+fFPz21NCAozkHwdIT8=\");\n_c = TaskProvider;\nvar _c;\n$RefreshReg$(_c, \"TaskProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","v4","uuidv4","jsxDEV","_jsxDEV","TaskContext","useTask","_s","context","Error","TaskProvider","children","_s2","tasks","setTasks","activeTimers","setActiveTimers","storedTasks","localStorage","getItem","JSON","parse","setItem","stringify","addTask","taskData","newTask","id","status","timeSpent","createdAt","Date","toISOString","startedAt","completedAt","prev","updateTask","taskId","updates","map","task","deleteTask","filter","stopTimer","startTimer","find","t","startTime","now","interval","setInterval","elapsed","Math","floor","timer","_tasks$find","clearInterval","newTimers","completeTask","getTasksByUser","userId","assignedTo","getTaskStats","userTasks","total","length","pending","inProgress","completed","overdue","deadline","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Ashish/CascadeProjects/task-scheduler-app/src/contexts/TaskContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\n\nconst TaskContext = createContext();\n\nexport const useTask = () => {\n  const context = useContext(TaskContext);\n  if (!context) {\n    throw new Error('useTask must be used within a TaskProvider');\n  }\n  return context;\n};\n\nexport const TaskProvider = ({ children }) => {\n  const [tasks, setTasks] = useState([]);\n  const [activeTimers, setActiveTimers] = useState({});\n\n  useEffect(() => {\n    // Load tasks from localStorage\n    const storedTasks = localStorage.getItem('taskflow_tasks');\n    if (storedTasks) {\n      setTasks(JSON.parse(storedTasks));\n    }\n  }, []);\n\n  useEffect(() => {\n    // Save tasks to localStorage whenever tasks change\n    localStorage.setItem('taskflow_tasks', JSON.stringify(tasks));\n  }, [tasks]);\n\n  const addTask = (taskData) => {\n    const newTask = {\n      id: uuidv4(),\n      ...taskData,\n      status: 'pending',\n      timeSpent: 0,\n      createdAt: new Date().toISOString(),\n      startedAt: null,\n      completedAt: null\n    };\n    setTasks(prev => [...prev, newTask]);\n    return newTask;\n  };\n\n  const updateTask = (taskId, updates) => {\n    setTasks(prev => prev.map(task => \n      task.id === taskId ? { ...task, ...updates } : task\n    ));\n  };\n\n  const deleteTask = (taskId) => {\n    setTasks(prev => prev.filter(task => task.id !== taskId));\n    // Stop timer if running\n    if (activeTimers[taskId]) {\n      stopTimer(taskId);\n    }\n  };\n\n  const startTimer = (taskId) => {\n    const task = tasks.find(t => t.id === taskId);\n    if (!task) return;\n\n    // Update task status and start time\n    updateTask(taskId, { \n      status: 'in-progress',\n      startedAt: task.startedAt || new Date().toISOString()\n    });\n\n    // Start interval timer\n    const startTime = Date.now();\n    const interval = setInterval(() => {\n      const elapsed = Math.floor((Date.now() - startTime) / 1000);\n      setTasks(prev => prev.map(task => \n        task.id === taskId \n          ? { ...task, timeSpent: (task.timeSpent || 0) + elapsed }\n          : task\n      ));\n    }, 1000);\n\n    setActiveTimers(prev => ({\n      ...prev,\n      [taskId]: { interval, startTime }\n    }));\n  };\n\n  const stopTimer = (taskId) => {\n    const timer = activeTimers[taskId];\n    if (timer) {\n      clearInterval(timer.interval);\n      const elapsed = Math.floor((Date.now() - timer.startTime) / 1000);\n      \n      updateTask(taskId, { \n        timeSpent: (tasks.find(t => t.id === taskId)?.timeSpent || 0) + elapsed,\n        status: 'paused'\n      });\n\n      setActiveTimers(prev => {\n        const newTimers = { ...prev };\n        delete newTimers[taskId];\n        return newTimers;\n      });\n    }\n  };\n\n  const completeTask = (taskId) => {\n    // Stop timer if running\n    if (activeTimers[taskId]) {\n      stopTimer(taskId);\n    }\n    \n    updateTask(taskId, { \n      status: 'completed',\n      completedAt: new Date().toISOString()\n    });\n  };\n\n  const getTasksByUser = (userId) => {\n    return tasks.filter(task => task.assignedTo === userId);\n  };\n\n  const getTaskStats = (userId) => {\n    const userTasks = getTasksByUser(userId);\n    return {\n      total: userTasks.length,\n      pending: userTasks.filter(t => t.status === 'pending').length,\n      inProgress: userTasks.filter(t => t.status === 'in-progress').length,\n      completed: userTasks.filter(t => t.status === 'completed').length,\n      overdue: userTasks.filter(t => \n        t.status !== 'completed' && \n        new Date(t.deadline) < new Date()\n      ).length\n    };\n  };\n\n  const value = {\n    tasks,\n    activeTimers,\n    addTask,\n    updateTask,\n    deleteTask,\n    startTimer,\n    stopTimer,\n    completeTask,\n    getTasksByUser,\n    getTaskStats\n  };\n\n  return (\n    <TaskContext.Provider value={value}>\n      {children}\n    </TaskContext.Provider>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}